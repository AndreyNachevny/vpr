# Регулярные выражения

Нужно написать на бумаге регулярное выражение и написать программу, 
которая бы выводила 1-20 слов из этого регулярного выражения.

## Алгоритм (ручная запись)

```text
У Вас, к примеру, есть множество выражений:
L = {a, ab, ac}

Из L множества мы видим, что выражения {a, ab, ac} начинаются всегда с «a» 
=> мы его можем «выделить из обшей массы». 
В лекции чей-то я читал, что само множество L можно представить в виде:
 L = a + ab + ac => | Но если мы выносим что-то, то вместо него нужно записать «e» | 
 => L = a(e + b + c)

{e} - элементарный язык

'пустое множество'^n = 'пустое множество'
'пустое множество'^* = {e}
e^* = {e}
x^0 = {e}

L + 'пустое множество' = L
L * 'пустое множество' = 'пустое множество'

Пример 2:

L = {a, ab, abc} = a + ab + abc = a(e + b + bc) = a(e + b(e + c))

Нас же просят преобразовать наше получившееся выражение обратно в множество
программным методом: написать программу для этого.

PS: Лучше использовать ограничение в 20 слов, чтобы не уйти случайно в бесконечность
```

### Пример входных данных:
```text
regex = 'a(b + c + d)a'
```
### Пример выходных данных:
```text
{aba, aca, ada}
```

## Важная информация

Насколько я понял, можно использовать обычные regex => не создавать свои реализации парсера регулярных выражений, 
а использовать встроенные библиотеки языка, что я и буду выполнять в реализации варианта 2.

## Реализация варианта #2

```text
E = {0, 1} Допускать цепочки, в которых стоят 3 подряд 0
```
Воспользуемся стандартным regex, тогда наша регулярка будет иметь следующий вид: `[01]*000[01]*`

### Нахождение регулярного множества, используя регулярное выражение:
```python
import re


def generate_regex_words(regex: str, *, limit: int, alphabet: list[str]) -> list[str]:
    pattern = re.compile(regex)
    result = []
    word = ''
    while len(result) < limit:
        if pattern.fullmatch(word):
            result.append(word)
            if len(result) == limit:
                break
        word = inc_word(word, alphabet)
    return result


def inc_word(word: str, alphabet: list[str]) -> str:
    if not word:
        return alphabet[0]
    if word[-1] == alphabet[-1]:
        return inc_word(word[:-1], alphabet) + alphabet[0]
    return word[:-1] + alphabet[alphabet.index(word[-1]) + 1]
```

Результатом функции `generate_regex_words` будет список слов, соответствующих регулярному выражению, например:
```python
>>> generate_regex_words("[01]*000[01]*", limit=10, alphabet=['0', '1'])
['000', '0000', '0001', '1000', '00000', '00001', '00010', '00011', '01000', '10000']
```

*Авторство: **Бояршинов Н.О***
