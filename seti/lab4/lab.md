# Лаба №4. Клиент-серверное взаимодействие посредством tcp-сокетов
## Файлы к лабе

- Порядок выполнения (+ варианты) [(.pdf)](https://github.com/whitekeep/vpr12/raw/main/seti/lab4/Laboratornaya_rabota_N_4.pdf)

## Инструкция по выполнению лабы

- Предоставлен готовый клиент-серверный проект с hello world.
- Написано для windows
- Вы выбираете вариант и пишите логику приложения
- Сначала запускается сервер, а потом клиент

## Файлы шаблонов:

- Шаблон сервера [(.zip)](https://github.com/xarll/tcpserver/archive/refs/heads/master.zip)
- Шаблон клиента [(.zip)](https://github.com/xarll/tcpclient/archive/refs/heads/master.zip)


## Инструкция и пример работы

### Сервер

Я написал легкую обработку клиентского запроса, аля мидлвари, но это не точно

Стартовая точка программы:
![изображение](https://user-images.githubusercontent.com/76239707/163667297-80c7cf45-292f-4e87-be59-15587f233093.png)

```c++
#include <iostream>
#include <string>

#include "Server.h"


std::string dirFinder(std::string search)
{

    std::string result = "hello, " + search;
    return result;
}




int main()
{
    setlocale(LC_ALL, "rus");
    startServer(dirFinder, "127.0.0.1", "27015");
    return 0;
}

```

Здесь находится стартовая точка программы, все манипуляции с клиентским запросом и с ответом происходят в этом файле. 
Взгяните внимательно на `startServer(dirFinder, "127.0.0.1", "27015");` это просто функция-loop, которая запускает бесконечную 
прослушку соединения.

В параметрах этой функции вы заметили `dirFinder` - просто название функции (функция может иметь любое название), которая находится выше; 
Сделано это для того, чтобы при запросе от клиента, сервер вызвал эту функцию с параметром типа `string` (параметр может иметь любое название, 
я назвал "search" для себя), далее внутри функции (в моем случае) `dirFinder` можнно менять запрос, производить какие-то действия и пр по лабе, а после 
вернуть из функции результат `return`, который отправится клиенту.

Краткое пояснения примера:<br>
* клиент отправляет текст<br>
* Сервер получает этот текст в функции (в моем случае) `dirFinder` и возвращает ответ клиенту<br>
* клиент получает ответ

### Клиент 

Я написал легкую обработку серверного запроса, аля requests в питоне<br>
По сути мы каждый раз открываем и закрываем соединение с сервером, хотя у меня<br>
был вариает всегда держать соединение открытым, но я отказался от этого<br>

Стартовая точка программы:
![изображение](https://user-images.githubusercontent.com/76239707/163668036-484d843b-adf0-4c14-a81d-73b9f27624d7.png)


```c++
#include <iostream>

#include "Client.h"

int main()
{
    setlocale(LC_ALL, "rus");

    const char* addresses = "127.0.0.1";
    const char* port = "27015";

    std::string result = request(Client(addresses, port), "Никита");
    std::cout << "От сервера: " << result << std::endl;

    std::string result2 = request(Client(addresses, port), "Полина");
    std::cout << "От сервера: " << result2 << std::endl;

    

    return 0;
}
```

Весь код можно писать поямо в `main()`

Функция `request(Client(addresses, port), "Никита")` принимает первым аргументом подключенный `SOCKET`, в нашем случае `Client(addresses, port)` 
вторым аргументом строку типа `string`, в нашем случае `"Никита"`; Сама функция передает серверу строку (в нашем случае 'Никита') и возвращает ответ сервера в формате `string`.


## Возможные ошибки

Если у вас возникает ошибка у клиента, связанная с `recvbuf` (ф-ция `getResp` в файле `Client.cpp`), то возможно вы передали слишком много информации за раз и Ваш буфер забит. Советую что-то сделать: переписать сервер на более универсальны вид (разделение информации на чанки) или просто увеличить значение буфера до 60000(к примеру)

![изображение](https://user-images.githubusercontent.com/76239707/163717960-731a17bf-4e6c-49fa-b550-ccac0cdb357a.png)

