# Лаба №5. Настройка сетевых экранов и технологии отображения портов (в процессе)
## Файлы к лабе

- Порядок выполнения [(.pdf)](./Metodichka_LR5.pdf)

## Нам понадобится
- ВМ 1 (Спамер или еще кто-то из плохих людей)
- ВМ 2 (Фаервол; Он же - щит, который будет отбивать атаки ВМ 1)
- ВМ 3 (потенциальный сервер)

## Описание
![изображение](https://user-images.githubusercontent.com/76239707/165601000-5d022fb9-6b74-4909-9dd2-1698c3bb207a.png)

Нам требуется построить такую систему, при которой...

#### Что такое iptables?
iptables является утилитой, выполняющей функции межсетевого экрана. Настройка iptables производится в командной строке, с помощью правил iptables можно разрешать или блокировать прохождение трафика. Когда происходит попытка установления соединения с текущей машиной, iptables просматривает список правил в списке, чтобы понять, как нужно поступить в этом случае. Если правила нет, то выполняется действие по умолчанию.

Как правило, itpables предустанавливается на всех Linux-дистрибутивах.

#### Типы правил 

Существует три типа правил iptables — input, **forward** и output.

- Input — Такие цепочки используются для контроля поведения входящих соединений. К примеру, если пользователь попробует подключиться к серверу по SSH, то iptables сравнит его IP-адрес со своим списком, чтобы разрешить или запретить доступ.

- **Forward** — Правила этого типа используются для обработки входящих сообщений, конечный пункт назначения которых не является текущим сервером. К примеру, в случае маршрутизатора, к нему подключаются многие пользователи и приложения, но данные не посылаются на сам маршрутизатор, они лишь передаются ему, чтобы он мог перенаправить их адресату. Если вы не занимаетесь настройкой маршрутизации или NAT, то правила этого типа использовать в работе не будете.

- Output — Такие цепочки используются для исходящих соединений. К прмиеру, если пользователь пытается отправинг запрос ping к сайту google.com, iptables изучит цепочку правил, чтобы понять, что нужно делать в случае ping и этого сайт, и только потом разрешит или запретит соединение.

## Начало

### Установка ВМ

Надеюсь, что за 4 лабы вы научились устанавливать ВМ (виртуальные машины) и не нуждаетесь в Божьей помощи, если это не так, то рекомендую посмотреть начало 3й лабы

#### Из особенностей установки стоит отметить:
- Установка аналогично лабе 2 (маршрутизатор)
- На всех 3х машинах советую установить сразу net-tools:
```apt install net-tools```

Т.е. нам нужны 3 машины, 2 из которых с разлиными сетевыми адаптерами, а 3тья должна иметь 2 адаптера, пример:
- ВМ1 Имеет только сетевой адаптер: "Сетевой мост"
- ВМ2 Имеет 2 сетевых адаптера: "Сетевой мост" и "Виртуальный хост адаптера"
- ВМ3 Имеет только сетевой адаптер: "Виртуальный хост адаптера"

На 2й машине (маршрутизатор) не забываем включить [ip forwarding](https://github.com/xarll/vpr12/blob/main/seti/lab2/lab.md#%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B0-%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%B0%D1%86%D0%B8%D0%B8-%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F-ip)

### Установка статического IP для всех 3х машин

аналогично: в 3й лабе понятно описано то, как это делать [netplan выдача статического ip](https://github.com/xarll/vpr12/blob/main/seti/lab3/lab3.md#%D1%81%D0%B1%D0%BE%D1%80-%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D0%B8-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D1%85-ip)

Нам следует для всех 3х машин зафиксировать ip, чтобы не испытывать проблем с этим в будущем, хотя этот пункт необязательный.<br/>
В моем случае после манипуляций я имею:
|№|Интерфейс|ВМ 1|ВМ 2|ВМ 3|
|---|---|---|---|---|
|1|enp0s3|`192.168.3.100`|`192.168.3.101`|`-`|
|2|enp0s8|`-`|`192.168.56.100`|`192.168.56.101`|

Я установил следующие настройки netplan
ВМ1:
![изображение](https://user-images.githubusercontent.com/76239707/165830445-5f8b2850-b23d-4b1f-a2cc-002b5a6ce184.png)
ВМ2:
![изображение](https://user-images.githubusercontent.com/76239707/165831020-49d98ae8-735a-4ffd-8b95-d7488a6e9f8a.png)
ВМ3:
![изображение](https://user-images.githubusercontent.com/76239707/165832024-99af16e4-af0a-4476-a024-9bd915503fd0.png)

#### Теперь пропишем маршруты (как в лаб2)
Выполним на ВМ 1 команду:

```sh
route add -net 192.168.56.0 netmask 255.255.255.0 gw 192.168.3.101
```
- `192.168.56.0` это сеть сетевого адптера ВМ 3 (ip в котором поставили всесто последнего октета нолик)
- `192.168.3.101` это доступный нам ip от ВМ 2

Но при успешной отправке пакетов, нам нужно получить ответ => пропишем обратный путь на ВМ 3:

Выполним на ВМ 3 команду:

```sh
route add -net 192.168.3.0 netmask 255.255.255.0 gw 192.168.56.100
```
- `192.168.3.0` это сеть сетевого адптера ВМ 1 (ip в котором поставили всесто последнего октета нолик)
- `192.168.56.100` это доступный нам ip от ВМ 2

После чего попробуем пропинговать из ВМ3 из ВМ1


## Настройка Firewall(Межсетевой экран)

Подготовку мы прошли, можем приступать к основной части

### Действия с соединениями

Рассмотрим три основных вида действий с соединениями:
- Accept — разрешить соединение;
- Drop — игнорировать соединение, вести себя так, будто его никогда не было. Действие подходит для случаев, когда нужно сделать так, чтобы источник запроса не узнал о его блокировке.
- Reject — заблокировать соединение и отправить в ответ сообщение об ошибке. Действие подходит для тех случаев, когда владелец сервера хочет дать понять, что соединение заблокировано файрволом.

### 1) Разрешаем и блокируем конкретные соединения
На ВМ2 (маршрутизатор) настроем политику игнорирования прямых(если пакет с маршрутом, т.е преднозначен не для ВМ2, а для ВМ3, то это не будет блокироваться) входящих пакетов из ВМ 1 (плохой компуктер),
для этого на ВМ2 пропишем следующее правило iptable:

```sh
iptables -A INPUT -s 192.168.3.100 -j DROP
```
Где `192.168.3.100` - ip(первой ВМ), на которое накладывается правило `DROP`, т.е. игнорирование соединения.
а INPUT означает блокирование прямых входящих соединений (не пакетов с маршрутом)

##### Протестируем:
На ВМ1(плохой клиент) попробуем послать пакеты на ВМ2(маршрутизатор):
```sh
ping 192.168.3.101
```
Получаем игнор от маршрутизатора.

Однако, если мы отправим пакеты из ВМ1 в ВМ3, то всё получится.
Это получится только из-за того, что мы указали значение флага A равное INPUT.

##### Удалим правило:
Для удаления правила, нам всего лишь следует заменить флаг A на D
Т.е на ВМ2 пропишем:
```sh
iptables -D INPUT -s 192.168.3.100 -j DROP
```
Теперь попробуем пропинговать ВМ2 из ВМ1:
```sh
ping 192.168.3.101
```
Все работает!

Заметки:
Чтобы удалить все правила из всех цепочек, достаточно прописать:
```sh
iptables -F
```
### 2) Блокировка пакетов со стороны маршрутизатора(основная настройка Firewall)
...


### Сохранение изменений

Внесенные в цепочки правил изменения пропадут при перезапуске iptables, так что их нужно сохранить с помощью специальной команды. В зависимости от используемого Linux-дистрибутива команда может выглядеть по-разному.

-Ubuntu:
```sh
=sudo /sbin/iptables-save
```
- Red Hat / CentOS:
```sh
=/sbin/service iptables save
```
- Или
```sh
=/etc/init.d/iptables save
```


